Renderer -> Scene + Camera
Scene -> Mesh + Object3D + Group + Light --/-- geometry + (Material -> texture)
Mesh -> Geometry + Material + Texture // They are independent objects, many mesh can be drawn with the same geometry/material
Geometry -> Vertex data
Material -> Surface properties used to draw geometry 
Texture -> Represent images

Example:

	const renderer = new THREE.WebGLRenderer(); 
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );
    // Another way of creating a renderer is by calling 'new THREE.WebGLRenderer({canvasElement})', I prefer this one.

    const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
    //THREE.PerspectiveCamera(fov -in radius-, aspect ratio, near, far)
    camera.position.z = 5;

    const scene = new THREE.Scene(); //Creates the root of the scene.
 
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshPhongMaterial( { color: 0x00ff00 } );
    const cube = new THREE.Mesh( geometry, material );
    scene.add( cube );

    const light = new THREE.DirectionalLight(0xFFFFFF, 1); // Light defaults its target to (0,0,0)
    // DirectionalLight(color -hexadecimal-, intensity)
    light.position.set(-1,2,4);
    scene.add(light);

    function render(time) {

        cube.rotation.x += time;
        cube.rotation.y += time;

        renderer.render( scene, camera );
        requestAnimationFrame( render );
    };

    requestAnimationFrame(render); // Asks the browser to reload the view of the page if the excecution of 'render' changes it. A chequear!!

-- Responsive Design --

[] To adapt the ratio when we resize the screen, we have to modify the camera aspect.

	const canvas = renderer.domElement;
	camera.aspect = canvas.clientWidth / canvas.clientHeight;
	camera.updateProjectionMatrix();

This code is put inside the render loop ('render').

[] To prevent the image from being 'blocky' (bad resolution due to changing the display size)...

...canvas elements have two sizes:
* Size displayed on the page
* Number of pixels in the canvas itself (drawingbuffer size)
	const pr = window.devicePixelRatio;
	renderer.setSize(canvas.clientWidth * pr | 0, canvas.clientHeight * pr | 0, false);
This code is also put inside the render loop. In both cases is convenient to check if the window has been resized.

-- Primitives --
Every geometry has a position (x,y,z) accesible and modificable through obj.position.x/y/z
										 rotation (x,y,z)                                      .rotation.x/y/z (radians); 
										 scale    (x,y,z)                                      .scale.x/y/z


* BoxGeometry()
  BoxGeometry(width, height, depth);
  BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments);	

* CircleGeometry()
  CircleGeometry(radius, segments) // segments refer to the amount of triangles that compose the circle.
  CircleGeometry(radius, segments, thetaStart, thetaEnd) // Theta (in radians) refer to the actual perimeter of the circle that will be covered.

* SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaEnd)

* TextGeometry() // 3d text generated from a font and a string.
	const loader = new THREE.fontLoader();
	loader.load('./url/to/font', (font) => {
		const text3d = new THREE.TextGeometry( 
			text,
			{
				font: font,
				size,
				height,
				curveSegments,
				...
			})
	})

* ConeGeometry()
  ConeGeometry(radius, height, radialSegments)
  ConeGeometry(radius, height, radialSegments, heightSegments, openEnd (default false), thetaStart, thetaEnd)

* CylinderGeometry()
* DodecahedronGeometry()
* ExtrudeGeometry(...) // Bezier curve directed geometry.
* IcosahedronGeometry()
* LatheGeometry(vector<THREE.vector2>) // Shape generated by spinning a line.

* ParametricGeometry(function: 2d -> 3d, slices, stacks)

* PlaneGeometry(width, height) // 2D plane
  PlaneGeometry(width, height, widthSegments, heightSegments)

* PolyhedronGeompetry(verticesOfInscriptionCube, indicesOfFaces, radius, detail); // Takes a set of triangles centered around a point and 
																				  // projects them into a sphere.

* RingGeometry(innerRadius, outerRadius, thetaSegments)
  RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaEnd)										  

* EdgesGeometry(anotherGeometryObject,
				        thresholdAngle) // Takes another geometry object and shows the edges between faces which angle surpass certain threshold.
* WireframeGeometry(anotherGeometryObject) // Takes another geometry object and shows the edges

* Points(geometry, material) // Draws points at the vertex

scene.background = aColor;

-- Scenegraph --
The scene is the core of three.js. It is a tree of objects, each object has a local position that is relative to its parent's'.

[scene.add(sunMesh)
sunMesh.add(earthMesh)]

Stablishing this relationship between objects in the scene, if the sun rotates, the earth will rotate around it.
If we scale the sunMesh x5 for example, the local space of the sun is 5 times bigger, anything put in that space will be multiplied by 5.
	Position and scale are multiplied by the scale factor of its parent.
We can make the sun and the earth childs of the same solarSystem, and so, the earth will rotate relative to the (0,0) of the solar system.

* Object3D() // has no geometry or material, just represents a local space.

* 	const axes = new THREE.AxesHelper();
	axes.material.depthTest = false; // To actually see the axes.
	axes.renderOrder = 1; // To get drown after all the spheres.
	anObject.add(AxesHelper()) // Shows the axis of the object.
